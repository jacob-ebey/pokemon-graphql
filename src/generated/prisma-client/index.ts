// Code generated by Prisma (prisma@1.33.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  item: (where?: ItemWhereInput) => Promise<boolean>;
  multiLang: (where?: MultiLangWhereInput) => Promise<boolean>;
  pokemon: (where?: PokemonWhereInput) => Promise<boolean>;
  pokemonBaseStats: (where?: PokemonBaseStatsWhereInput) => Promise<boolean>;
  pokemonSkill: (where?: PokemonSkillWhereInput) => Promise<boolean>;
  pokemonType: (where?: PokemonTypeWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  item: (where: ItemWhereUniqueInput) => ItemNullablePromise;
  items: (args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Item>;
  itemsConnection: (args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ItemConnectionPromise;
  multiLangs: (args?: {
    where?: MultiLangWhereInput;
    orderBy?: MultiLangOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MultiLang>;
  multiLangsConnection: (args?: {
    where?: MultiLangWhereInput;
    orderBy?: MultiLangOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MultiLangConnectionPromise;
  pokemon: (where: PokemonWhereUniqueInput) => PokemonNullablePromise;
  pokemons: (args?: {
    where?: PokemonWhereInput;
    orderBy?: PokemonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Pokemon>;
  pokemonsConnection: (args?: {
    where?: PokemonWhereInput;
    orderBy?: PokemonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PokemonConnectionPromise;
  pokemonBaseStatses: (args?: {
    where?: PokemonBaseStatsWhereInput;
    orderBy?: PokemonBaseStatsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PokemonBaseStats>;
  pokemonBaseStatsesConnection: (args?: {
    where?: PokemonBaseStatsWhereInput;
    orderBy?: PokemonBaseStatsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PokemonBaseStatsConnectionPromise;
  pokemonSkill: (
    where: PokemonSkillWhereUniqueInput
  ) => PokemonSkillNullablePromise;
  pokemonSkills: (args?: {
    where?: PokemonSkillWhereInput;
    orderBy?: PokemonSkillOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PokemonSkill>;
  pokemonSkillsConnection: (args?: {
    where?: PokemonSkillWhereInput;
    orderBy?: PokemonSkillOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PokemonSkillConnectionPromise;
  pokemonType: (
    where: PokemonTypeWhereUniqueInput
  ) => PokemonTypeNullablePromise;
  pokemonTypes: (args?: {
    where?: PokemonTypeWhereInput;
    orderBy?: PokemonTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PokemonType>;
  pokemonTypesConnection: (args?: {
    where?: PokemonTypeWhereInput;
    orderBy?: PokemonTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PokemonTypeConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createItem: (data: ItemCreateInput) => ItemPromise;
  updateItem: (args: {
    data: ItemUpdateInput;
    where: ItemWhereUniqueInput;
  }) => ItemPromise;
  updateManyItems: (args: {
    data: ItemUpdateManyMutationInput;
    where?: ItemWhereInput;
  }) => BatchPayloadPromise;
  upsertItem: (args: {
    where: ItemWhereUniqueInput;
    create: ItemCreateInput;
    update: ItemUpdateInput;
  }) => ItemPromise;
  deleteItem: (where: ItemWhereUniqueInput) => ItemPromise;
  deleteManyItems: (where?: ItemWhereInput) => BatchPayloadPromise;
  createMultiLang: (data: MultiLangCreateInput) => MultiLangPromise;
  updateManyMultiLangs: (args: {
    data: MultiLangUpdateManyMutationInput;
    where?: MultiLangWhereInput;
  }) => BatchPayloadPromise;
  deleteManyMultiLangs: (where?: MultiLangWhereInput) => BatchPayloadPromise;
  createPokemon: (data: PokemonCreateInput) => PokemonPromise;
  updatePokemon: (args: {
    data: PokemonUpdateInput;
    where: PokemonWhereUniqueInput;
  }) => PokemonPromise;
  updateManyPokemons: (args: {
    data: PokemonUpdateManyMutationInput;
    where?: PokemonWhereInput;
  }) => BatchPayloadPromise;
  upsertPokemon: (args: {
    where: PokemonWhereUniqueInput;
    create: PokemonCreateInput;
    update: PokemonUpdateInput;
  }) => PokemonPromise;
  deletePokemon: (where: PokemonWhereUniqueInput) => PokemonPromise;
  deleteManyPokemons: (where?: PokemonWhereInput) => BatchPayloadPromise;
  createPokemonBaseStats: (
    data: PokemonBaseStatsCreateInput
  ) => PokemonBaseStatsPromise;
  updateManyPokemonBaseStatses: (args: {
    data: PokemonBaseStatsUpdateManyMutationInput;
    where?: PokemonBaseStatsWhereInput;
  }) => BatchPayloadPromise;
  deleteManyPokemonBaseStatses: (
    where?: PokemonBaseStatsWhereInput
  ) => BatchPayloadPromise;
  createPokemonSkill: (data: PokemonSkillCreateInput) => PokemonSkillPromise;
  updatePokemonSkill: (args: {
    data: PokemonSkillUpdateInput;
    where: PokemonSkillWhereUniqueInput;
  }) => PokemonSkillPromise;
  updateManyPokemonSkills: (args: {
    data: PokemonSkillUpdateManyMutationInput;
    where?: PokemonSkillWhereInput;
  }) => BatchPayloadPromise;
  upsertPokemonSkill: (args: {
    where: PokemonSkillWhereUniqueInput;
    create: PokemonSkillCreateInput;
    update: PokemonSkillUpdateInput;
  }) => PokemonSkillPromise;
  deletePokemonSkill: (
    where: PokemonSkillWhereUniqueInput
  ) => PokemonSkillPromise;
  deleteManyPokemonSkills: (
    where?: PokemonSkillWhereInput
  ) => BatchPayloadPromise;
  createPokemonType: (data: PokemonTypeCreateInput) => PokemonTypePromise;
  updatePokemonType: (args: {
    data: PokemonTypeUpdateInput;
    where: PokemonTypeWhereUniqueInput;
  }) => PokemonTypePromise;
  updateManyPokemonTypes: (args: {
    data: PokemonTypeUpdateManyMutationInput;
    where?: PokemonTypeWhereInput;
  }) => BatchPayloadPromise;
  upsertPokemonType: (args: {
    where: PokemonTypeWhereUniqueInput;
    create: PokemonTypeCreateInput;
    update: PokemonTypeUpdateInput;
  }) => PokemonTypePromise;
  deletePokemonType: (where: PokemonTypeWhereUniqueInput) => PokemonTypePromise;
  deleteManyPokemonTypes: (
    where?: PokemonTypeWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  item: (
    where?: ItemSubscriptionWhereInput
  ) => ItemSubscriptionPayloadSubscription;
  multiLang: (
    where?: MultiLangSubscriptionWhereInput
  ) => MultiLangSubscriptionPayloadSubscription;
  pokemon: (
    where?: PokemonSubscriptionWhereInput
  ) => PokemonSubscriptionPayloadSubscription;
  pokemonBaseStats: (
    where?: PokemonBaseStatsSubscriptionWhereInput
  ) => PokemonBaseStatsSubscriptionPayloadSubscription;
  pokemonSkill: (
    where?: PokemonSkillSubscriptionWhereInput
  ) => PokemonSkillSubscriptionPayloadSubscription;
  pokemonType: (
    where?: PokemonTypeSubscriptionWhereInput
  ) => PokemonTypeSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "pokedexNumber_ASC"
  | "pokedexNumber_DESC"
  | "nameSearch_ASC"
  | "nameSearch_DESC";

export type MultiLangOrderByInput =
  | "english_ASC"
  | "english_DESC"
  | "japanese_ASC"
  | "japanese_DESC"
  | "chinese_ASC"
  | "chinese_DESC";

export type PokemonTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "english_ASC"
  | "english_DESC"
  | "chinese_ASC"
  | "chinese_DESC"
  | "japanese_ASC"
  | "japanese_DESC";

export type PokemonOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "pokedexNumber_ASC"
  | "pokedexNumber_DESC"
  | "nameSearch_ASC"
  | "nameSearch_DESC";

export type PokemonBaseStatsOrderByInput =
  | "hp_ASC"
  | "hp_DESC"
  | "attack_ASC"
  | "attack_DESC"
  | "defense_ASC"
  | "defense_DESC"
  | "spAttack_ASC"
  | "spAttack_DESC"
  | "spDefense_ASC"
  | "spDefense_DESC"
  | "speed_ASC"
  | "speed_DESC";

export type PokemonSkillOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "pokedexNumber_ASC"
  | "pokedexNumber_DESC"
  | "accuracy_ASC"
  | "accuracy_DESC"
  | "power_ASC"
  | "power_DESC"
  | "pp_ASC"
  | "pp_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface MultiLangUpdateOneRequiredInput {
  create?: Maybe<MultiLangCreateInput>;
  update?: Maybe<MultiLangUpdateDataInput>;
  upsert?: Maybe<MultiLangUpsertNestedInput>;
}

export type ItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  pokedexNumber?: Maybe<Int>;
}>;

export type PokemonSkillWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  pokedexNumber?: Maybe<Int>;
}>;

export interface PokemonTypeCreateInput {
  english: String;
  chinese: String;
  japanese: String;
}

export interface PokemonBaseStatsUpdateOneRequiredInput {
  create?: Maybe<PokemonBaseStatsCreateInput>;
  update?: Maybe<PokemonBaseStatsUpdateDataInput>;
  upsert?: Maybe<PokemonBaseStatsUpsertNestedInput>;
}

export interface PokemonSkillSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PokemonSkillWhereInput>;
  AND?: Maybe<
    PokemonSkillSubscriptionWhereInput[] | PokemonSkillSubscriptionWhereInput
  >;
  OR?: Maybe<
    PokemonSkillSubscriptionWhereInput[] | PokemonSkillSubscriptionWhereInput
  >;
  NOT?: Maybe<
    PokemonSkillSubscriptionWhereInput[] | PokemonSkillSubscriptionWhereInput
  >;
}

export interface PokemonSkillWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  pokedexNumber?: Maybe<Int>;
  pokedexNumber_not?: Maybe<Int>;
  pokedexNumber_in?: Maybe<Int[] | Int>;
  pokedexNumber_not_in?: Maybe<Int[] | Int>;
  pokedexNumber_lt?: Maybe<Int>;
  pokedexNumber_lte?: Maybe<Int>;
  pokedexNumber_gt?: Maybe<Int>;
  pokedexNumber_gte?: Maybe<Int>;
  name?: Maybe<MultiLangWhereInput>;
  accuracy?: Maybe<Int>;
  accuracy_not?: Maybe<Int>;
  accuracy_in?: Maybe<Int[] | Int>;
  accuracy_not_in?: Maybe<Int[] | Int>;
  accuracy_lt?: Maybe<Int>;
  accuracy_lte?: Maybe<Int>;
  accuracy_gt?: Maybe<Int>;
  accuracy_gte?: Maybe<Int>;
  power?: Maybe<Int>;
  power_not?: Maybe<Int>;
  power_in?: Maybe<Int[] | Int>;
  power_not_in?: Maybe<Int[] | Int>;
  power_lt?: Maybe<Int>;
  power_lte?: Maybe<Int>;
  power_gt?: Maybe<Int>;
  power_gte?: Maybe<Int>;
  pp?: Maybe<Int>;
  pp_not?: Maybe<Int>;
  pp_in?: Maybe<Int[] | Int>;
  pp_not_in?: Maybe<Int[] | Int>;
  pp_lt?: Maybe<Int>;
  pp_lte?: Maybe<Int>;
  pp_gt?: Maybe<Int>;
  pp_gte?: Maybe<Int>;
  type?: Maybe<PokemonTypeWhereInput>;
  AND?: Maybe<PokemonSkillWhereInput[] | PokemonSkillWhereInput>;
  OR?: Maybe<PokemonSkillWhereInput[] | PokemonSkillWhereInput>;
  NOT?: Maybe<PokemonSkillWhereInput[] | PokemonSkillWhereInput>;
}

export interface MultiLangWhereInput {
  english?: Maybe<String>;
  english_not?: Maybe<String>;
  english_in?: Maybe<String[] | String>;
  english_not_in?: Maybe<String[] | String>;
  english_lt?: Maybe<String>;
  english_lte?: Maybe<String>;
  english_gt?: Maybe<String>;
  english_gte?: Maybe<String>;
  english_contains?: Maybe<String>;
  english_not_contains?: Maybe<String>;
  english_starts_with?: Maybe<String>;
  english_not_starts_with?: Maybe<String>;
  english_ends_with?: Maybe<String>;
  english_not_ends_with?: Maybe<String>;
  japanese?: Maybe<String>;
  japanese_not?: Maybe<String>;
  japanese_in?: Maybe<String[] | String>;
  japanese_not_in?: Maybe<String[] | String>;
  japanese_lt?: Maybe<String>;
  japanese_lte?: Maybe<String>;
  japanese_gt?: Maybe<String>;
  japanese_gte?: Maybe<String>;
  japanese_contains?: Maybe<String>;
  japanese_not_contains?: Maybe<String>;
  japanese_starts_with?: Maybe<String>;
  japanese_not_starts_with?: Maybe<String>;
  japanese_ends_with?: Maybe<String>;
  japanese_not_ends_with?: Maybe<String>;
  chinese?: Maybe<String>;
  chinese_not?: Maybe<String>;
  chinese_in?: Maybe<String[] | String>;
  chinese_not_in?: Maybe<String[] | String>;
  chinese_lt?: Maybe<String>;
  chinese_lte?: Maybe<String>;
  chinese_gt?: Maybe<String>;
  chinese_gte?: Maybe<String>;
  chinese_contains?: Maybe<String>;
  chinese_not_contains?: Maybe<String>;
  chinese_starts_with?: Maybe<String>;
  chinese_not_starts_with?: Maybe<String>;
  chinese_ends_with?: Maybe<String>;
  chinese_not_ends_with?: Maybe<String>;
  AND?: Maybe<MultiLangWhereInput[] | MultiLangWhereInput>;
  OR?: Maybe<MultiLangWhereInput[] | MultiLangWhereInput>;
  NOT?: Maybe<MultiLangWhereInput[] | MultiLangWhereInput>;
}

export interface PokemonTypeUpdateManyDataInput {
  english?: Maybe<String>;
  chinese?: Maybe<String>;
  japanese?: Maybe<String>;
}

export interface MultiLangSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MultiLangWhereInput>;
  AND?: Maybe<
    MultiLangSubscriptionWhereInput[] | MultiLangSubscriptionWhereInput
  >;
  OR?: Maybe<
    MultiLangSubscriptionWhereInput[] | MultiLangSubscriptionWhereInput
  >;
  NOT?: Maybe<
    MultiLangSubscriptionWhereInput[] | MultiLangSubscriptionWhereInput
  >;
}

export interface PokemonTypeUpdateManyWithWhereNestedInput {
  where: PokemonTypeScalarWhereInput;
  data: PokemonTypeUpdateManyDataInput;
}

export type PokemonWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  pokedexNumber?: Maybe<Int>;
}>;

export interface PokemonTypeScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  english?: Maybe<String>;
  english_not?: Maybe<String>;
  english_in?: Maybe<String[] | String>;
  english_not_in?: Maybe<String[] | String>;
  english_lt?: Maybe<String>;
  english_lte?: Maybe<String>;
  english_gt?: Maybe<String>;
  english_gte?: Maybe<String>;
  english_contains?: Maybe<String>;
  english_not_contains?: Maybe<String>;
  english_starts_with?: Maybe<String>;
  english_not_starts_with?: Maybe<String>;
  english_ends_with?: Maybe<String>;
  english_not_ends_with?: Maybe<String>;
  chinese?: Maybe<String>;
  chinese_not?: Maybe<String>;
  chinese_in?: Maybe<String[] | String>;
  chinese_not_in?: Maybe<String[] | String>;
  chinese_lt?: Maybe<String>;
  chinese_lte?: Maybe<String>;
  chinese_gt?: Maybe<String>;
  chinese_gte?: Maybe<String>;
  chinese_contains?: Maybe<String>;
  chinese_not_contains?: Maybe<String>;
  chinese_starts_with?: Maybe<String>;
  chinese_not_starts_with?: Maybe<String>;
  chinese_ends_with?: Maybe<String>;
  chinese_not_ends_with?: Maybe<String>;
  japanese?: Maybe<String>;
  japanese_not?: Maybe<String>;
  japanese_in?: Maybe<String[] | String>;
  japanese_not_in?: Maybe<String[] | String>;
  japanese_lt?: Maybe<String>;
  japanese_lte?: Maybe<String>;
  japanese_gt?: Maybe<String>;
  japanese_gte?: Maybe<String>;
  japanese_contains?: Maybe<String>;
  japanese_not_contains?: Maybe<String>;
  japanese_starts_with?: Maybe<String>;
  japanese_not_starts_with?: Maybe<String>;
  japanese_ends_with?: Maybe<String>;
  japanese_not_ends_with?: Maybe<String>;
  AND?: Maybe<PokemonTypeScalarWhereInput[] | PokemonTypeScalarWhereInput>;
  OR?: Maybe<PokemonTypeScalarWhereInput[] | PokemonTypeScalarWhereInput>;
  NOT?: Maybe<PokemonTypeScalarWhereInput[] | PokemonTypeScalarWhereInput>;
}

export interface PokemonTypeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  english?: Maybe<String>;
  english_not?: Maybe<String>;
  english_in?: Maybe<String[] | String>;
  english_not_in?: Maybe<String[] | String>;
  english_lt?: Maybe<String>;
  english_lte?: Maybe<String>;
  english_gt?: Maybe<String>;
  english_gte?: Maybe<String>;
  english_contains?: Maybe<String>;
  english_not_contains?: Maybe<String>;
  english_starts_with?: Maybe<String>;
  english_not_starts_with?: Maybe<String>;
  english_ends_with?: Maybe<String>;
  english_not_ends_with?: Maybe<String>;
  chinese?: Maybe<String>;
  chinese_not?: Maybe<String>;
  chinese_in?: Maybe<String[] | String>;
  chinese_not_in?: Maybe<String[] | String>;
  chinese_lt?: Maybe<String>;
  chinese_lte?: Maybe<String>;
  chinese_gt?: Maybe<String>;
  chinese_gte?: Maybe<String>;
  chinese_contains?: Maybe<String>;
  chinese_not_contains?: Maybe<String>;
  chinese_starts_with?: Maybe<String>;
  chinese_not_starts_with?: Maybe<String>;
  chinese_ends_with?: Maybe<String>;
  chinese_not_ends_with?: Maybe<String>;
  japanese?: Maybe<String>;
  japanese_not?: Maybe<String>;
  japanese_in?: Maybe<String[] | String>;
  japanese_not_in?: Maybe<String[] | String>;
  japanese_lt?: Maybe<String>;
  japanese_lte?: Maybe<String>;
  japanese_gt?: Maybe<String>;
  japanese_gte?: Maybe<String>;
  japanese_contains?: Maybe<String>;
  japanese_not_contains?: Maybe<String>;
  japanese_starts_with?: Maybe<String>;
  japanese_not_starts_with?: Maybe<String>;
  japanese_ends_with?: Maybe<String>;
  japanese_not_ends_with?: Maybe<String>;
  AND?: Maybe<PokemonTypeWhereInput[] | PokemonTypeWhereInput>;
  OR?: Maybe<PokemonTypeWhereInput[] | PokemonTypeWhereInput>;
  NOT?: Maybe<PokemonTypeWhereInput[] | PokemonTypeWhereInput>;
}

export interface PokemonTypeUpsertWithWhereUniqueNestedInput {
  where: PokemonTypeWhereUniqueInput;
  update: PokemonTypeUpdateDataInput;
  create: PokemonTypeCreateInput;
}

export interface PokemonTypeUpdateInput {
  english?: Maybe<String>;
  chinese?: Maybe<String>;
  japanese?: Maybe<String>;
}

export type PokemonTypeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  english?: Maybe<String>;
}>;

export interface PokemonTypeUpsertNestedInput {
  update: PokemonTypeUpdateDataInput;
  create: PokemonTypeCreateInput;
}

export interface PokemonTypeUpdateDataInput {
  english?: Maybe<String>;
  chinese?: Maybe<String>;
  japanese?: Maybe<String>;
}

export interface PokemonBaseStatsWhereInput {
  hp?: Maybe<Float>;
  hp_not?: Maybe<Float>;
  hp_in?: Maybe<Float[] | Float>;
  hp_not_in?: Maybe<Float[] | Float>;
  hp_lt?: Maybe<Float>;
  hp_lte?: Maybe<Float>;
  hp_gt?: Maybe<Float>;
  hp_gte?: Maybe<Float>;
  attack?: Maybe<Float>;
  attack_not?: Maybe<Float>;
  attack_in?: Maybe<Float[] | Float>;
  attack_not_in?: Maybe<Float[] | Float>;
  attack_lt?: Maybe<Float>;
  attack_lte?: Maybe<Float>;
  attack_gt?: Maybe<Float>;
  attack_gte?: Maybe<Float>;
  defense?: Maybe<Float>;
  defense_not?: Maybe<Float>;
  defense_in?: Maybe<Float[] | Float>;
  defense_not_in?: Maybe<Float[] | Float>;
  defense_lt?: Maybe<Float>;
  defense_lte?: Maybe<Float>;
  defense_gt?: Maybe<Float>;
  defense_gte?: Maybe<Float>;
  spAttack?: Maybe<Float>;
  spAttack_not?: Maybe<Float>;
  spAttack_in?: Maybe<Float[] | Float>;
  spAttack_not_in?: Maybe<Float[] | Float>;
  spAttack_lt?: Maybe<Float>;
  spAttack_lte?: Maybe<Float>;
  spAttack_gt?: Maybe<Float>;
  spAttack_gte?: Maybe<Float>;
  spDefense?: Maybe<Float>;
  spDefense_not?: Maybe<Float>;
  spDefense_in?: Maybe<Float[] | Float>;
  spDefense_not_in?: Maybe<Float[] | Float>;
  spDefense_lt?: Maybe<Float>;
  spDefense_lte?: Maybe<Float>;
  spDefense_gt?: Maybe<Float>;
  spDefense_gte?: Maybe<Float>;
  speed?: Maybe<Float>;
  speed_not?: Maybe<Float>;
  speed_in?: Maybe<Float[] | Float>;
  speed_not_in?: Maybe<Float[] | Float>;
  speed_lt?: Maybe<Float>;
  speed_lte?: Maybe<Float>;
  speed_gt?: Maybe<Float>;
  speed_gte?: Maybe<Float>;
  AND?: Maybe<PokemonBaseStatsWhereInput[] | PokemonBaseStatsWhereInput>;
  OR?: Maybe<PokemonBaseStatsWhereInput[] | PokemonBaseStatsWhereInput>;
  NOT?: Maybe<PokemonBaseStatsWhereInput[] | PokemonBaseStatsWhereInput>;
}

export interface PokemonTypeUpdateWithWhereUniqueNestedInput {
  where: PokemonTypeWhereUniqueInput;
  data: PokemonTypeUpdateDataInput;
}

export interface PokemonSkillUpdateInput {
  pokedexNumber?: Maybe<Int>;
  name?: Maybe<MultiLangUpdateOneRequiredInput>;
  accuracy?: Maybe<Int>;
  power?: Maybe<Int>;
  pp?: Maybe<Int>;
  type?: Maybe<PokemonTypeUpdateOneRequiredInput>;
}

export interface PokemonTypeUpdateManyInput {
  create?: Maybe<PokemonTypeCreateInput[] | PokemonTypeCreateInput>;
  update?: Maybe<
    | PokemonTypeUpdateWithWhereUniqueNestedInput[]
    | PokemonTypeUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | PokemonTypeUpsertWithWhereUniqueNestedInput[]
    | PokemonTypeUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<PokemonTypeWhereUniqueInput[] | PokemonTypeWhereUniqueInput>;
  connect?: Maybe<PokemonTypeWhereUniqueInput[] | PokemonTypeWhereUniqueInput>;
  set?: Maybe<PokemonTypeWhereUniqueInput[] | PokemonTypeWhereUniqueInput>;
  disconnect?: Maybe<
    PokemonTypeWhereUniqueInput[] | PokemonTypeWhereUniqueInput
  >;
  deleteMany?: Maybe<
    PokemonTypeScalarWhereInput[] | PokemonTypeScalarWhereInput
  >;
  updateMany?: Maybe<
    | PokemonTypeUpdateManyWithWhereNestedInput[]
    | PokemonTypeUpdateManyWithWhereNestedInput
  >;
}

export interface PokemonSkillCreateInput {
  pokedexNumber: Int;
  name: MultiLangCreateOneInput;
  accuracy: Int;
  power: Int;
  pp: Int;
  type: PokemonTypeCreateOneInput;
}

export interface PokemonBaseStatsUpsertNestedInput {
  update: PokemonBaseStatsUpdateDataInput;
  create: PokemonBaseStatsCreateInput;
}

export interface PokemonTypeCreateManyInput {
  create?: Maybe<PokemonTypeCreateInput[] | PokemonTypeCreateInput>;
  connect?: Maybe<PokemonTypeWhereUniqueInput[] | PokemonTypeWhereUniqueInput>;
}

export interface ItemCreateInput {
  pokedexNumber: Int;
  nameSearch: String;
  name: MultiLangCreateOneInput;
}

export interface PokemonUpdateManyMutationInput {
  pokedexNumber?: Maybe<Int>;
  nameSearch?: Maybe<String>;
}

export interface MultiLangCreateOneInput {
  create?: Maybe<MultiLangCreateInput>;
}

export interface PokemonTypeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PokemonTypeWhereInput>;
  AND?: Maybe<
    PokemonTypeSubscriptionWhereInput[] | PokemonTypeSubscriptionWhereInput
  >;
  OR?: Maybe<
    PokemonTypeSubscriptionWhereInput[] | PokemonTypeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    PokemonTypeSubscriptionWhereInput[] | PokemonTypeSubscriptionWhereInput
  >;
}

export interface MultiLangCreateInput {
  english: String;
  japanese: String;
  chinese: String;
}

export interface PokemonSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PokemonWhereInput>;
  AND?: Maybe<PokemonSubscriptionWhereInput[] | PokemonSubscriptionWhereInput>;
  OR?: Maybe<PokemonSubscriptionWhereInput[] | PokemonSubscriptionWhereInput>;
  NOT?: Maybe<PokemonSubscriptionWhereInput[] | PokemonSubscriptionWhereInput>;
}

export interface ItemUpdateInput {
  pokedexNumber?: Maybe<Int>;
  nameSearch?: Maybe<String>;
  name?: Maybe<MultiLangUpdateOneRequiredInput>;
}

export interface PokemonTypeUpdateManyMutationInput {
  english?: Maybe<String>;
  chinese?: Maybe<String>;
  japanese?: Maybe<String>;
}

export interface PokemonUpdateInput {
  pokedexNumber?: Maybe<Int>;
  nameSearch?: Maybe<String>;
  name?: Maybe<MultiLangUpdateOneRequiredInput>;
  types?: Maybe<PokemonTypeUpdateManyInput>;
  base?: Maybe<PokemonBaseStatsUpdateOneRequiredInput>;
}

export interface PokemonSkillUpdateManyMutationInput {
  pokedexNumber?: Maybe<Int>;
  accuracy?: Maybe<Int>;
  power?: Maybe<Int>;
  pp?: Maybe<Int>;
}

export interface MultiLangUpdateDataInput {
  english?: Maybe<String>;
  japanese?: Maybe<String>;
  chinese?: Maybe<String>;
}

export interface PokemonTypeUpdateOneRequiredInput {
  create?: Maybe<PokemonTypeCreateInput>;
  update?: Maybe<PokemonTypeUpdateDataInput>;
  upsert?: Maybe<PokemonTypeUpsertNestedInput>;
  connect?: Maybe<PokemonTypeWhereUniqueInput>;
}

export interface MultiLangUpsertNestedInput {
  update: MultiLangUpdateDataInput;
  create: MultiLangCreateInput;
}

export interface PokemonBaseStatsUpdateManyMutationInput {
  hp?: Maybe<Float>;
  attack?: Maybe<Float>;
  defense?: Maybe<Float>;
  spAttack?: Maybe<Float>;
  spDefense?: Maybe<Float>;
  speed?: Maybe<Float>;
}

export interface ItemUpdateManyMutationInput {
  pokedexNumber?: Maybe<Int>;
  nameSearch?: Maybe<String>;
}

export interface PokemonBaseStatsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PokemonBaseStatsWhereInput>;
  AND?: Maybe<
    | PokemonBaseStatsSubscriptionWhereInput[]
    | PokemonBaseStatsSubscriptionWhereInput
  >;
  OR?: Maybe<
    | PokemonBaseStatsSubscriptionWhereInput[]
    | PokemonBaseStatsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PokemonBaseStatsSubscriptionWhereInput[]
    | PokemonBaseStatsSubscriptionWhereInput
  >;
}

export interface ItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  pokedexNumber?: Maybe<Int>;
  pokedexNumber_not?: Maybe<Int>;
  pokedexNumber_in?: Maybe<Int[] | Int>;
  pokedexNumber_not_in?: Maybe<Int[] | Int>;
  pokedexNumber_lt?: Maybe<Int>;
  pokedexNumber_lte?: Maybe<Int>;
  pokedexNumber_gt?: Maybe<Int>;
  pokedexNumber_gte?: Maybe<Int>;
  nameSearch?: Maybe<String>;
  nameSearch_not?: Maybe<String>;
  nameSearch_in?: Maybe<String[] | String>;
  nameSearch_not_in?: Maybe<String[] | String>;
  nameSearch_lt?: Maybe<String>;
  nameSearch_lte?: Maybe<String>;
  nameSearch_gt?: Maybe<String>;
  nameSearch_gte?: Maybe<String>;
  nameSearch_contains?: Maybe<String>;
  nameSearch_not_contains?: Maybe<String>;
  nameSearch_starts_with?: Maybe<String>;
  nameSearch_not_starts_with?: Maybe<String>;
  nameSearch_ends_with?: Maybe<String>;
  nameSearch_not_ends_with?: Maybe<String>;
  name?: Maybe<MultiLangWhereInput>;
  AND?: Maybe<ItemWhereInput[] | ItemWhereInput>;
  OR?: Maybe<ItemWhereInput[] | ItemWhereInput>;
  NOT?: Maybe<ItemWhereInput[] | ItemWhereInput>;
}

export interface PokemonCreateInput {
  pokedexNumber: Int;
  nameSearch: String;
  name: MultiLangCreateOneInput;
  types?: Maybe<PokemonTypeCreateManyInput>;
  base: PokemonBaseStatsCreateOneInput;
}

export interface MultiLangUpdateManyMutationInput {
  english?: Maybe<String>;
  japanese?: Maybe<String>;
  chinese?: Maybe<String>;
}

export interface PokemonBaseStatsCreateOneInput {
  create?: Maybe<PokemonBaseStatsCreateInput>;
}

export interface PokemonBaseStatsCreateInput {
  hp: Float;
  attack: Float;
  defense: Float;
  spAttack: Float;
  spDefense: Float;
  speed: Float;
}

export interface PokemonWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  pokedexNumber?: Maybe<Int>;
  pokedexNumber_not?: Maybe<Int>;
  pokedexNumber_in?: Maybe<Int[] | Int>;
  pokedexNumber_not_in?: Maybe<Int[] | Int>;
  pokedexNumber_lt?: Maybe<Int>;
  pokedexNumber_lte?: Maybe<Int>;
  pokedexNumber_gt?: Maybe<Int>;
  pokedexNumber_gte?: Maybe<Int>;
  nameSearch?: Maybe<String>;
  nameSearch_not?: Maybe<String>;
  nameSearch_in?: Maybe<String[] | String>;
  nameSearch_not_in?: Maybe<String[] | String>;
  nameSearch_lt?: Maybe<String>;
  nameSearch_lte?: Maybe<String>;
  nameSearch_gt?: Maybe<String>;
  nameSearch_gte?: Maybe<String>;
  nameSearch_contains?: Maybe<String>;
  nameSearch_not_contains?: Maybe<String>;
  nameSearch_starts_with?: Maybe<String>;
  nameSearch_not_starts_with?: Maybe<String>;
  nameSearch_ends_with?: Maybe<String>;
  nameSearch_not_ends_with?: Maybe<String>;
  name?: Maybe<MultiLangWhereInput>;
  types_every?: Maybe<PokemonTypeWhereInput>;
  types_some?: Maybe<PokemonTypeWhereInput>;
  types_none?: Maybe<PokemonTypeWhereInput>;
  base?: Maybe<PokemonBaseStatsWhereInput>;
  AND?: Maybe<PokemonWhereInput[] | PokemonWhereInput>;
  OR?: Maybe<PokemonWhereInput[] | PokemonWhereInput>;
  NOT?: Maybe<PokemonWhereInput[] | PokemonWhereInput>;
}

export interface ItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ItemWhereInput>;
  AND?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
  OR?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
  NOT?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
}

export interface PokemonBaseStatsUpdateDataInput {
  hp?: Maybe<Float>;
  attack?: Maybe<Float>;
  defense?: Maybe<Float>;
  spAttack?: Maybe<Float>;
  spDefense?: Maybe<Float>;
  speed?: Maybe<Float>;
}

export interface PokemonTypeCreateOneInput {
  create?: Maybe<PokemonTypeCreateInput>;
  connect?: Maybe<PokemonTypeWhereUniqueInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface PokemonTypePreviousValues {
  id: ID_Output;
  english: String;
  chinese: String;
  japanese: String;
}

export interface PokemonTypePreviousValuesPromise
  extends Promise<PokemonTypePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  english: () => Promise<String>;
  chinese: () => Promise<String>;
  japanese: () => Promise<String>;
}

export interface PokemonTypePreviousValuesSubscription
  extends Promise<AsyncIterator<PokemonTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  english: () => Promise<AsyncIterator<String>>;
  chinese: () => Promise<AsyncIterator<String>>;
  japanese: () => Promise<AsyncIterator<String>>;
}

export interface ItemConnection {
  pageInfo: PageInfo;
  edges: ItemEdge[];
}

export interface ItemConnectionPromise
  extends Promise<ItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ItemEdge>>() => T;
  aggregate: <T = AggregateItemPromise>() => T;
}

export interface ItemConnectionSubscription
  extends Promise<AsyncIterator<ItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateItemSubscription>() => T;
}

export interface PokemonType {
  id: ID_Output;
  english: String;
  chinese: String;
  japanese: String;
}

export interface PokemonTypePromise extends Promise<PokemonType>, Fragmentable {
  id: () => Promise<ID_Output>;
  english: () => Promise<String>;
  chinese: () => Promise<String>;
  japanese: () => Promise<String>;
}

export interface PokemonTypeSubscription
  extends Promise<AsyncIterator<PokemonType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  english: () => Promise<AsyncIterator<String>>;
  chinese: () => Promise<AsyncIterator<String>>;
  japanese: () => Promise<AsyncIterator<String>>;
}

export interface PokemonTypeNullablePromise
  extends Promise<PokemonType | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  english: () => Promise<String>;
  chinese: () => Promise<String>;
  japanese: () => Promise<String>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface PokemonBaseStats {
  hp: Float;
  attack: Float;
  defense: Float;
  spAttack: Float;
  spDefense: Float;
  speed: Float;
}

export interface PokemonBaseStatsPromise
  extends Promise<PokemonBaseStats>,
    Fragmentable {
  hp: () => Promise<Float>;
  attack: () => Promise<Float>;
  defense: () => Promise<Float>;
  spAttack: () => Promise<Float>;
  spDefense: () => Promise<Float>;
  speed: () => Promise<Float>;
}

export interface PokemonBaseStatsSubscription
  extends Promise<AsyncIterator<PokemonBaseStats>>,
    Fragmentable {
  hp: () => Promise<AsyncIterator<Float>>;
  attack: () => Promise<AsyncIterator<Float>>;
  defense: () => Promise<AsyncIterator<Float>>;
  spAttack: () => Promise<AsyncIterator<Float>>;
  spDefense: () => Promise<AsyncIterator<Float>>;
  speed: () => Promise<AsyncIterator<Float>>;
}

export interface PokemonBaseStatsNullablePromise
  extends Promise<PokemonBaseStats | null>,
    Fragmentable {
  hp: () => Promise<Float>;
  attack: () => Promise<Float>;
  defense: () => Promise<Float>;
  spAttack: () => Promise<Float>;
  spDefense: () => Promise<Float>;
  speed: () => Promise<Float>;
}

export interface ItemEdge {
  node: Item;
  cursor: String;
}

export interface ItemEdgePromise extends Promise<ItemEdge>, Fragmentable {
  node: <T = ItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ItemEdgeSubscription
  extends Promise<AsyncIterator<ItemEdge>>,
    Fragmentable {
  node: <T = ItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface Pokemon {
  id: ID_Output;
  pokedexNumber: Int;
  nameSearch: String;
}

export interface PokemonPromise extends Promise<Pokemon>, Fragmentable {
  id: () => Promise<ID_Output>;
  pokedexNumber: () => Promise<Int>;
  nameSearch: () => Promise<String>;
  name: <T = MultiLangPromise>() => T;
  types: <T = FragmentableArray<PokemonType>>(args?: {
    where?: PokemonTypeWhereInput;
    orderBy?: PokemonTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  base: <T = PokemonBaseStatsPromise>() => T;
}

export interface PokemonSubscription
  extends Promise<AsyncIterator<Pokemon>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  pokedexNumber: () => Promise<AsyncIterator<Int>>;
  nameSearch: () => Promise<AsyncIterator<String>>;
  name: <T = MultiLangSubscription>() => T;
  types: <T = Promise<AsyncIterator<PokemonTypeSubscription>>>(args?: {
    where?: PokemonTypeWhereInput;
    orderBy?: PokemonTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  base: <T = PokemonBaseStatsSubscription>() => T;
}

export interface PokemonNullablePromise
  extends Promise<Pokemon | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  pokedexNumber: () => Promise<Int>;
  nameSearch: () => Promise<String>;
  name: <T = MultiLangPromise>() => T;
  types: <T = FragmentableArray<PokemonType>>(args?: {
    where?: PokemonTypeWhereInput;
    orderBy?: PokemonTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  base: <T = PokemonBaseStatsPromise>() => T;
}

export interface AggregatePokemonType {
  count: Int;
}

export interface AggregatePokemonTypePromise
  extends Promise<AggregatePokemonType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePokemonTypeSubscription
  extends Promise<AsyncIterator<AggregatePokemonType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PokemonTypeConnection {
  pageInfo: PageInfo;
  edges: PokemonTypeEdge[];
}

export interface PokemonTypeConnectionPromise
  extends Promise<PokemonTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PokemonTypeEdge>>() => T;
  aggregate: <T = AggregatePokemonTypePromise>() => T;
}

export interface PokemonTypeConnectionSubscription
  extends Promise<AsyncIterator<PokemonTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PokemonTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePokemonTypeSubscription>() => T;
}

export interface AggregateMultiLang {
  count: Int;
}

export interface AggregateMultiLangPromise
  extends Promise<AggregateMultiLang>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMultiLangSubscription
  extends Promise<AsyncIterator<AggregateMultiLang>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PokemonSkillEdge {
  node: PokemonSkill;
  cursor: String;
}

export interface PokemonSkillEdgePromise
  extends Promise<PokemonSkillEdge>,
    Fragmentable {
  node: <T = PokemonSkillPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PokemonSkillEdgeSubscription
  extends Promise<AsyncIterator<PokemonSkillEdge>>,
    Fragmentable {
  node: <T = PokemonSkillSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PokemonSkillSubscriptionPayload {
  mutation: MutationType;
  node: PokemonSkill;
  updatedFields: String[];
  previousValues: PokemonSkillPreviousValues;
}

export interface PokemonSkillSubscriptionPayloadPromise
  extends Promise<PokemonSkillSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PokemonSkillPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PokemonSkillPreviousValuesPromise>() => T;
}

export interface PokemonSkillSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PokemonSkillSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PokemonSkillSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PokemonSkillPreviousValuesSubscription>() => T;
}

export interface Item {
  id: ID_Output;
  pokedexNumber: Int;
  nameSearch: String;
}

export interface ItemPromise extends Promise<Item>, Fragmentable {
  id: () => Promise<ID_Output>;
  pokedexNumber: () => Promise<Int>;
  nameSearch: () => Promise<String>;
  name: <T = MultiLangPromise>() => T;
}

export interface ItemSubscription
  extends Promise<AsyncIterator<Item>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  pokedexNumber: () => Promise<AsyncIterator<Int>>;
  nameSearch: () => Promise<AsyncIterator<String>>;
  name: <T = MultiLangSubscription>() => T;
}

export interface ItemNullablePromise
  extends Promise<Item | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  pokedexNumber: () => Promise<Int>;
  nameSearch: () => Promise<String>;
  name: <T = MultiLangPromise>() => T;
}

export interface ItemSubscriptionPayload {
  mutation: MutationType;
  node: Item;
  updatedFields: String[];
  previousValues: ItemPreviousValues;
}

export interface ItemSubscriptionPayloadPromise
  extends Promise<ItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ItemPreviousValuesPromise>() => T;
}

export interface ItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ItemPreviousValuesSubscription>() => T;
}

export interface AggregatePokemonBaseStats {
  count: Int;
}

export interface AggregatePokemonBaseStatsPromise
  extends Promise<AggregatePokemonBaseStats>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePokemonBaseStatsSubscription
  extends Promise<AsyncIterator<AggregatePokemonBaseStats>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ItemPreviousValues {
  id: ID_Output;
  pokedexNumber: Int;
  nameSearch: String;
}

export interface ItemPreviousValuesPromise
  extends Promise<ItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  pokedexNumber: () => Promise<Int>;
  nameSearch: () => Promise<String>;
}

export interface ItemPreviousValuesSubscription
  extends Promise<AsyncIterator<ItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  pokedexNumber: () => Promise<AsyncIterator<Int>>;
  nameSearch: () => Promise<AsyncIterator<String>>;
}

export interface PokemonBaseStatsConnection {
  pageInfo: PageInfo;
  edges: PokemonBaseStatsEdge[];
}

export interface PokemonBaseStatsConnectionPromise
  extends Promise<PokemonBaseStatsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PokemonBaseStatsEdge>>() => T;
  aggregate: <T = AggregatePokemonBaseStatsPromise>() => T;
}

export interface PokemonBaseStatsConnectionSubscription
  extends Promise<AsyncIterator<PokemonBaseStatsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PokemonBaseStatsEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePokemonBaseStatsSubscription>() => T;
}

export interface MultiLangEdge {
  node: MultiLang;
  cursor: String;
}

export interface MultiLangEdgePromise
  extends Promise<MultiLangEdge>,
    Fragmentable {
  node: <T = MultiLangPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MultiLangEdgeSubscription
  extends Promise<AsyncIterator<MultiLangEdge>>,
    Fragmentable {
  node: <T = MultiLangSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePokemon {
  count: Int;
}

export interface AggregatePokemonPromise
  extends Promise<AggregatePokemon>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePokemonSubscription
  extends Promise<AsyncIterator<AggregatePokemon>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MultiLangSubscriptionPayload {
  mutation: MutationType;
  node: MultiLang;
  updatedFields: String[];
  previousValues: MultiLangPreviousValues;
}

export interface MultiLangSubscriptionPayloadPromise
  extends Promise<MultiLangSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MultiLangPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MultiLangPreviousValuesPromise>() => T;
}

export interface MultiLangSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MultiLangSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MultiLangSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MultiLangPreviousValuesSubscription>() => T;
}

export interface PokemonConnection {
  pageInfo: PageInfo;
  edges: PokemonEdge[];
}

export interface PokemonConnectionPromise
  extends Promise<PokemonConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PokemonEdge>>() => T;
  aggregate: <T = AggregatePokemonPromise>() => T;
}

export interface PokemonConnectionSubscription
  extends Promise<AsyncIterator<PokemonConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PokemonEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePokemonSubscription>() => T;
}

export interface MultiLangPreviousValues {
  english: String;
  japanese: String;
  chinese: String;
}

export interface MultiLangPreviousValuesPromise
  extends Promise<MultiLangPreviousValues>,
    Fragmentable {
  english: () => Promise<String>;
  japanese: () => Promise<String>;
  chinese: () => Promise<String>;
}

export interface MultiLangPreviousValuesSubscription
  extends Promise<AsyncIterator<MultiLangPreviousValues>>,
    Fragmentable {
  english: () => Promise<AsyncIterator<String>>;
  japanese: () => Promise<AsyncIterator<String>>;
  chinese: () => Promise<AsyncIterator<String>>;
}

export interface PokemonSkillPreviousValues {
  id: ID_Output;
  pokedexNumber: Int;
  accuracy: Int;
  power: Int;
  pp: Int;
}

export interface PokemonSkillPreviousValuesPromise
  extends Promise<PokemonSkillPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  pokedexNumber: () => Promise<Int>;
  accuracy: () => Promise<Int>;
  power: () => Promise<Int>;
  pp: () => Promise<Int>;
}

export interface PokemonSkillPreviousValuesSubscription
  extends Promise<AsyncIterator<PokemonSkillPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  pokedexNumber: () => Promise<AsyncIterator<Int>>;
  accuracy: () => Promise<AsyncIterator<Int>>;
  power: () => Promise<AsyncIterator<Int>>;
  pp: () => Promise<AsyncIterator<Int>>;
}

export interface MultiLangConnection {
  pageInfo: PageInfo;
  edges: MultiLangEdge[];
}

export interface MultiLangConnectionPromise
  extends Promise<MultiLangConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MultiLangEdge>>() => T;
  aggregate: <T = AggregateMultiLangPromise>() => T;
}

export interface MultiLangConnectionSubscription
  extends Promise<AsyncIterator<MultiLangConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MultiLangEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMultiLangSubscription>() => T;
}

export interface AggregatePokemonSkill {
  count: Int;
}

export interface AggregatePokemonSkillPromise
  extends Promise<AggregatePokemonSkill>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePokemonSkillSubscription
  extends Promise<AsyncIterator<AggregatePokemonSkill>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PokemonSubscriptionPayload {
  mutation: MutationType;
  node: Pokemon;
  updatedFields: String[];
  previousValues: PokemonPreviousValues;
}

export interface PokemonSubscriptionPayloadPromise
  extends Promise<PokemonSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PokemonPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PokemonPreviousValuesPromise>() => T;
}

export interface PokemonSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PokemonSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PokemonSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PokemonPreviousValuesSubscription>() => T;
}

export interface PokemonSkill {
  id: ID_Output;
  pokedexNumber: Int;
  accuracy: Int;
  power: Int;
  pp: Int;
}

export interface PokemonSkillPromise
  extends Promise<PokemonSkill>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  pokedexNumber: () => Promise<Int>;
  name: <T = MultiLangPromise>() => T;
  accuracy: () => Promise<Int>;
  power: () => Promise<Int>;
  pp: () => Promise<Int>;
  type: <T = PokemonTypePromise>() => T;
}

export interface PokemonSkillSubscription
  extends Promise<AsyncIterator<PokemonSkill>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  pokedexNumber: () => Promise<AsyncIterator<Int>>;
  name: <T = MultiLangSubscription>() => T;
  accuracy: () => Promise<AsyncIterator<Int>>;
  power: () => Promise<AsyncIterator<Int>>;
  pp: () => Promise<AsyncIterator<Int>>;
  type: <T = PokemonTypeSubscription>() => T;
}

export interface PokemonSkillNullablePromise
  extends Promise<PokemonSkill | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  pokedexNumber: () => Promise<Int>;
  name: <T = MultiLangPromise>() => T;
  accuracy: () => Promise<Int>;
  power: () => Promise<Int>;
  pp: () => Promise<Int>;
  type: <T = PokemonTypePromise>() => T;
}

export interface PokemonTypeSubscriptionPayload {
  mutation: MutationType;
  node: PokemonType;
  updatedFields: String[];
  previousValues: PokemonTypePreviousValues;
}

export interface PokemonTypeSubscriptionPayloadPromise
  extends Promise<PokemonTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PokemonTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PokemonTypePreviousValuesPromise>() => T;
}

export interface PokemonTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PokemonTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PokemonTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PokemonTypePreviousValuesSubscription>() => T;
}

export interface PokemonBaseStatsPreviousValues {
  hp: Float;
  attack: Float;
  defense: Float;
  spAttack: Float;
  spDefense: Float;
  speed: Float;
}

export interface PokemonBaseStatsPreviousValuesPromise
  extends Promise<PokemonBaseStatsPreviousValues>,
    Fragmentable {
  hp: () => Promise<Float>;
  attack: () => Promise<Float>;
  defense: () => Promise<Float>;
  spAttack: () => Promise<Float>;
  spDefense: () => Promise<Float>;
  speed: () => Promise<Float>;
}

export interface PokemonBaseStatsPreviousValuesSubscription
  extends Promise<AsyncIterator<PokemonBaseStatsPreviousValues>>,
    Fragmentable {
  hp: () => Promise<AsyncIterator<Float>>;
  attack: () => Promise<AsyncIterator<Float>>;
  defense: () => Promise<AsyncIterator<Float>>;
  spAttack: () => Promise<AsyncIterator<Float>>;
  spDefense: () => Promise<AsyncIterator<Float>>;
  speed: () => Promise<AsyncIterator<Float>>;
}

export interface PokemonBaseStatsSubscriptionPayload {
  mutation: MutationType;
  node: PokemonBaseStats;
  updatedFields: String[];
  previousValues: PokemonBaseStatsPreviousValues;
}

export interface PokemonBaseStatsSubscriptionPayloadPromise
  extends Promise<PokemonBaseStatsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PokemonBaseStatsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PokemonBaseStatsPreviousValuesPromise>() => T;
}

export interface PokemonBaseStatsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PokemonBaseStatsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PokemonBaseStatsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PokemonBaseStatsPreviousValuesSubscription>() => T;
}

export interface AggregateItem {
  count: Int;
}

export interface AggregateItemPromise
  extends Promise<AggregateItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateItemSubscription
  extends Promise<AsyncIterator<AggregateItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PokemonPreviousValues {
  id: ID_Output;
  pokedexNumber: Int;
  nameSearch: String;
}

export interface PokemonPreviousValuesPromise
  extends Promise<PokemonPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  pokedexNumber: () => Promise<Int>;
  nameSearch: () => Promise<String>;
}

export interface PokemonPreviousValuesSubscription
  extends Promise<AsyncIterator<PokemonPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  pokedexNumber: () => Promise<AsyncIterator<Int>>;
  nameSearch: () => Promise<AsyncIterator<String>>;
}

export interface PokemonEdge {
  node: Pokemon;
  cursor: String;
}

export interface PokemonEdgePromise extends Promise<PokemonEdge>, Fragmentable {
  node: <T = PokemonPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PokemonEdgeSubscription
  extends Promise<AsyncIterator<PokemonEdge>>,
    Fragmentable {
  node: <T = PokemonSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PokemonBaseStatsEdge {
  node: PokemonBaseStats;
  cursor: String;
}

export interface PokemonBaseStatsEdgePromise
  extends Promise<PokemonBaseStatsEdge>,
    Fragmentable {
  node: <T = PokemonBaseStatsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PokemonBaseStatsEdgeSubscription
  extends Promise<AsyncIterator<PokemonBaseStatsEdge>>,
    Fragmentable {
  node: <T = PokemonBaseStatsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PokemonSkillConnection {
  pageInfo: PageInfo;
  edges: PokemonSkillEdge[];
}

export interface PokemonSkillConnectionPromise
  extends Promise<PokemonSkillConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PokemonSkillEdge>>() => T;
  aggregate: <T = AggregatePokemonSkillPromise>() => T;
}

export interface PokemonSkillConnectionSubscription
  extends Promise<AsyncIterator<PokemonSkillConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PokemonSkillEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePokemonSkillSubscription>() => T;
}

export interface PokemonTypeEdge {
  node: PokemonType;
  cursor: String;
}

export interface PokemonTypeEdgePromise
  extends Promise<PokemonTypeEdge>,
    Fragmentable {
  node: <T = PokemonTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PokemonTypeEdgeSubscription
  extends Promise<AsyncIterator<PokemonTypeEdge>>,
    Fragmentable {
  node: <T = PokemonTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MultiLang {
  english: String;
  japanese: String;
  chinese: String;
}

export interface MultiLangPromise extends Promise<MultiLang>, Fragmentable {
  english: () => Promise<String>;
  japanese: () => Promise<String>;
  chinese: () => Promise<String>;
}

export interface MultiLangSubscription
  extends Promise<AsyncIterator<MultiLang>>,
    Fragmentable {
  english: () => Promise<AsyncIterator<String>>;
  japanese: () => Promise<AsyncIterator<String>>;
  chinese: () => Promise<AsyncIterator<String>>;
}

export interface MultiLangNullablePromise
  extends Promise<MultiLang | null>,
    Fragmentable {
  english: () => Promise<String>;
  japanese: () => Promise<String>;
  chinese: () => Promise<String>;
}

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "MultiLang",
    embedded: false
  },
  {
    name: "Pokemon",
    embedded: false
  },
  {
    name: "PokemonType",
    embedded: false
  },
  {
    name: "PokemonBaseStats",
    embedded: false
  },
  {
    name: "PokemonSkill",
    embedded: false
  },
  {
    name: "Item",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`,
  secret: `${process.env["PRISMA_SECRET"]}`
});
export const prisma = new Prisma();
