// Code generated by Prisma (prisma@1.33.0). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateItem {
  count: Int!
}

type AggregateMultiLang {
  count: Int!
}

type AggregatePokemon {
  count: Int!
}

type AggregatePokemonBaseStats {
  count: Int!
}

type AggregatePokemonSkill {
  count: Int!
}

type AggregatePokemonType {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Item {
  id: ID!
  pokedexNumber: Int!
  nameSearch: String!
  name: MultiLang!
}

type ItemConnection {
  pageInfo: PageInfo!
  edges: [ItemEdge]!
  aggregate: AggregateItem!
}

input ItemCreateInput {
  pokedexNumber: Int!
  nameSearch: String!
  name: MultiLangCreateOneInput!
}

type ItemEdge {
  node: Item!
  cursor: String!
}

enum ItemOrderByInput {
  id_ASC
  id_DESC
  pokedexNumber_ASC
  pokedexNumber_DESC
  nameSearch_ASC
  nameSearch_DESC
}

type ItemPreviousValues {
  id: ID!
  pokedexNumber: Int!
  nameSearch: String!
}

type ItemSubscriptionPayload {
  mutation: MutationType!
  node: Item
  updatedFields: [String!]
  previousValues: ItemPreviousValues
}

input ItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ItemWhereInput
  AND: [ItemSubscriptionWhereInput!]
  OR: [ItemSubscriptionWhereInput!]
  NOT: [ItemSubscriptionWhereInput!]
}

input ItemUpdateInput {
  pokedexNumber: Int
  nameSearch: String
  name: MultiLangUpdateOneRequiredInput
}

input ItemUpdateManyMutationInput {
  pokedexNumber: Int
  nameSearch: String
}

input ItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  pokedexNumber: Int
  pokedexNumber_not: Int
  pokedexNumber_in: [Int!]
  pokedexNumber_not_in: [Int!]
  pokedexNumber_lt: Int
  pokedexNumber_lte: Int
  pokedexNumber_gt: Int
  pokedexNumber_gte: Int
  nameSearch: String
  nameSearch_not: String
  nameSearch_in: [String!]
  nameSearch_not_in: [String!]
  nameSearch_lt: String
  nameSearch_lte: String
  nameSearch_gt: String
  nameSearch_gte: String
  nameSearch_contains: String
  nameSearch_not_contains: String
  nameSearch_starts_with: String
  nameSearch_not_starts_with: String
  nameSearch_ends_with: String
  nameSearch_not_ends_with: String
  name: MultiLangWhereInput
  AND: [ItemWhereInput!]
  OR: [ItemWhereInput!]
  NOT: [ItemWhereInput!]
}

input ItemWhereUniqueInput {
  id: ID
  pokedexNumber: Int
}

scalar Long

type MultiLang {
  english: String!
  japanese: String!
  chinese: String!
}

type MultiLangConnection {
  pageInfo: PageInfo!
  edges: [MultiLangEdge]!
  aggregate: AggregateMultiLang!
}

input MultiLangCreateInput {
  english: String!
  japanese: String!
  chinese: String!
}

input MultiLangCreateOneInput {
  create: MultiLangCreateInput
}

type MultiLangEdge {
  node: MultiLang!
  cursor: String!
}

enum MultiLangOrderByInput {
  english_ASC
  english_DESC
  japanese_ASC
  japanese_DESC
  chinese_ASC
  chinese_DESC
}

type MultiLangPreviousValues {
  english: String!
  japanese: String!
  chinese: String!
}

type MultiLangSubscriptionPayload {
  mutation: MutationType!
  node: MultiLang
  updatedFields: [String!]
  previousValues: MultiLangPreviousValues
}

input MultiLangSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MultiLangWhereInput
  AND: [MultiLangSubscriptionWhereInput!]
  OR: [MultiLangSubscriptionWhereInput!]
  NOT: [MultiLangSubscriptionWhereInput!]
}

input MultiLangUpdateDataInput {
  english: String
  japanese: String
  chinese: String
}

input MultiLangUpdateManyMutationInput {
  english: String
  japanese: String
  chinese: String
}

input MultiLangUpdateOneRequiredInput {
  create: MultiLangCreateInput
  update: MultiLangUpdateDataInput
  upsert: MultiLangUpsertNestedInput
}

input MultiLangUpsertNestedInput {
  update: MultiLangUpdateDataInput!
  create: MultiLangCreateInput!
}

input MultiLangWhereInput {
  english: String
  english_not: String
  english_in: [String!]
  english_not_in: [String!]
  english_lt: String
  english_lte: String
  english_gt: String
  english_gte: String
  english_contains: String
  english_not_contains: String
  english_starts_with: String
  english_not_starts_with: String
  english_ends_with: String
  english_not_ends_with: String
  japanese: String
  japanese_not: String
  japanese_in: [String!]
  japanese_not_in: [String!]
  japanese_lt: String
  japanese_lte: String
  japanese_gt: String
  japanese_gte: String
  japanese_contains: String
  japanese_not_contains: String
  japanese_starts_with: String
  japanese_not_starts_with: String
  japanese_ends_with: String
  japanese_not_ends_with: String
  chinese: String
  chinese_not: String
  chinese_in: [String!]
  chinese_not_in: [String!]
  chinese_lt: String
  chinese_lte: String
  chinese_gt: String
  chinese_gte: String
  chinese_contains: String
  chinese_not_contains: String
  chinese_starts_with: String
  chinese_not_starts_with: String
  chinese_ends_with: String
  chinese_not_ends_with: String
  AND: [MultiLangWhereInput!]
  OR: [MultiLangWhereInput!]
  NOT: [MultiLangWhereInput!]
}

type Mutation {
  createItem(data: ItemCreateInput!): Item!
  updateItem(data: ItemUpdateInput!, where: ItemWhereUniqueInput!): Item
  updateManyItems(data: ItemUpdateManyMutationInput!, where: ItemWhereInput): BatchPayload!
  upsertItem(where: ItemWhereUniqueInput!, create: ItemCreateInput!, update: ItemUpdateInput!): Item!
  deleteItem(where: ItemWhereUniqueInput!): Item
  deleteManyItems(where: ItemWhereInput): BatchPayload!
  createMultiLang(data: MultiLangCreateInput!): MultiLang!
  updateManyMultiLangs(data: MultiLangUpdateManyMutationInput!, where: MultiLangWhereInput): BatchPayload!
  deleteManyMultiLangs(where: MultiLangWhereInput): BatchPayload!
  createPokemon(data: PokemonCreateInput!): Pokemon!
  updatePokemon(data: PokemonUpdateInput!, where: PokemonWhereUniqueInput!): Pokemon
  updateManyPokemons(data: PokemonUpdateManyMutationInput!, where: PokemonWhereInput): BatchPayload!
  upsertPokemon(where: PokemonWhereUniqueInput!, create: PokemonCreateInput!, update: PokemonUpdateInput!): Pokemon!
  deletePokemon(where: PokemonWhereUniqueInput!): Pokemon
  deleteManyPokemons(where: PokemonWhereInput): BatchPayload!
  createPokemonBaseStats(data: PokemonBaseStatsCreateInput!): PokemonBaseStats!
  updateManyPokemonBaseStatses(data: PokemonBaseStatsUpdateManyMutationInput!, where: PokemonBaseStatsWhereInput): BatchPayload!
  deleteManyPokemonBaseStatses(where: PokemonBaseStatsWhereInput): BatchPayload!
  createPokemonSkill(data: PokemonSkillCreateInput!): PokemonSkill!
  updatePokemonSkill(data: PokemonSkillUpdateInput!, where: PokemonSkillWhereUniqueInput!): PokemonSkill
  updateManyPokemonSkills(data: PokemonSkillUpdateManyMutationInput!, where: PokemonSkillWhereInput): BatchPayload!
  upsertPokemonSkill(where: PokemonSkillWhereUniqueInput!, create: PokemonSkillCreateInput!, update: PokemonSkillUpdateInput!): PokemonSkill!
  deletePokemonSkill(where: PokemonSkillWhereUniqueInput!): PokemonSkill
  deleteManyPokemonSkills(where: PokemonSkillWhereInput): BatchPayload!
  createPokemonType(data: PokemonTypeCreateInput!): PokemonType!
  updatePokemonType(data: PokemonTypeUpdateInput!, where: PokemonTypeWhereUniqueInput!): PokemonType
  updateManyPokemonTypes(data: PokemonTypeUpdateManyMutationInput!, where: PokemonTypeWhereInput): BatchPayload!
  upsertPokemonType(where: PokemonTypeWhereUniqueInput!, create: PokemonTypeCreateInput!, update: PokemonTypeUpdateInput!): PokemonType!
  deletePokemonType(where: PokemonTypeWhereUniqueInput!): PokemonType
  deleteManyPokemonTypes(where: PokemonTypeWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Pokemon {
  id: ID!
  pokedexNumber: Int!
  nameSearch: String!
  name: MultiLang!
  types(where: PokemonTypeWhereInput, orderBy: PokemonTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PokemonType!]
  base: PokemonBaseStats!
}

type PokemonBaseStats {
  hp: Float!
  attack: Float!
  defense: Float!
  spAttack: Float!
  spDefense: Float!
  speed: Float!
}

type PokemonBaseStatsConnection {
  pageInfo: PageInfo!
  edges: [PokemonBaseStatsEdge]!
  aggregate: AggregatePokemonBaseStats!
}

input PokemonBaseStatsCreateInput {
  hp: Float!
  attack: Float!
  defense: Float!
  spAttack: Float!
  spDefense: Float!
  speed: Float!
}

input PokemonBaseStatsCreateOneInput {
  create: PokemonBaseStatsCreateInput
}

type PokemonBaseStatsEdge {
  node: PokemonBaseStats!
  cursor: String!
}

enum PokemonBaseStatsOrderByInput {
  hp_ASC
  hp_DESC
  attack_ASC
  attack_DESC
  defense_ASC
  defense_DESC
  spAttack_ASC
  spAttack_DESC
  spDefense_ASC
  spDefense_DESC
  speed_ASC
  speed_DESC
}

type PokemonBaseStatsPreviousValues {
  hp: Float!
  attack: Float!
  defense: Float!
  spAttack: Float!
  spDefense: Float!
  speed: Float!
}

type PokemonBaseStatsSubscriptionPayload {
  mutation: MutationType!
  node: PokemonBaseStats
  updatedFields: [String!]
  previousValues: PokemonBaseStatsPreviousValues
}

input PokemonBaseStatsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PokemonBaseStatsWhereInput
  AND: [PokemonBaseStatsSubscriptionWhereInput!]
  OR: [PokemonBaseStatsSubscriptionWhereInput!]
  NOT: [PokemonBaseStatsSubscriptionWhereInput!]
}

input PokemonBaseStatsUpdateDataInput {
  hp: Float
  attack: Float
  defense: Float
  spAttack: Float
  spDefense: Float
  speed: Float
}

input PokemonBaseStatsUpdateManyMutationInput {
  hp: Float
  attack: Float
  defense: Float
  spAttack: Float
  spDefense: Float
  speed: Float
}

input PokemonBaseStatsUpdateOneRequiredInput {
  create: PokemonBaseStatsCreateInput
  update: PokemonBaseStatsUpdateDataInput
  upsert: PokemonBaseStatsUpsertNestedInput
}

input PokemonBaseStatsUpsertNestedInput {
  update: PokemonBaseStatsUpdateDataInput!
  create: PokemonBaseStatsCreateInput!
}

input PokemonBaseStatsWhereInput {
  hp: Float
  hp_not: Float
  hp_in: [Float!]
  hp_not_in: [Float!]
  hp_lt: Float
  hp_lte: Float
  hp_gt: Float
  hp_gte: Float
  attack: Float
  attack_not: Float
  attack_in: [Float!]
  attack_not_in: [Float!]
  attack_lt: Float
  attack_lte: Float
  attack_gt: Float
  attack_gte: Float
  defense: Float
  defense_not: Float
  defense_in: [Float!]
  defense_not_in: [Float!]
  defense_lt: Float
  defense_lte: Float
  defense_gt: Float
  defense_gte: Float
  spAttack: Float
  spAttack_not: Float
  spAttack_in: [Float!]
  spAttack_not_in: [Float!]
  spAttack_lt: Float
  spAttack_lte: Float
  spAttack_gt: Float
  spAttack_gte: Float
  spDefense: Float
  spDefense_not: Float
  spDefense_in: [Float!]
  spDefense_not_in: [Float!]
  spDefense_lt: Float
  spDefense_lte: Float
  spDefense_gt: Float
  spDefense_gte: Float
  speed: Float
  speed_not: Float
  speed_in: [Float!]
  speed_not_in: [Float!]
  speed_lt: Float
  speed_lte: Float
  speed_gt: Float
  speed_gte: Float
  AND: [PokemonBaseStatsWhereInput!]
  OR: [PokemonBaseStatsWhereInput!]
  NOT: [PokemonBaseStatsWhereInput!]
}

type PokemonConnection {
  pageInfo: PageInfo!
  edges: [PokemonEdge]!
  aggregate: AggregatePokemon!
}

input PokemonCreateInput {
  pokedexNumber: Int!
  nameSearch: String!
  name: MultiLangCreateOneInput!
  types: PokemonTypeCreateManyInput
  base: PokemonBaseStatsCreateOneInput!
}

type PokemonEdge {
  node: Pokemon!
  cursor: String!
}

enum PokemonOrderByInput {
  id_ASC
  id_DESC
  pokedexNumber_ASC
  pokedexNumber_DESC
  nameSearch_ASC
  nameSearch_DESC
}

type PokemonPreviousValues {
  id: ID!
  pokedexNumber: Int!
  nameSearch: String!
}

type PokemonSkill {
  id: ID!
  pokedexNumber: Int!
  name: MultiLang!
  accuracy: Int!
  power: Int!
  pp: Int!
  type: PokemonType!
}

type PokemonSkillConnection {
  pageInfo: PageInfo!
  edges: [PokemonSkillEdge]!
  aggregate: AggregatePokemonSkill!
}

input PokemonSkillCreateInput {
  pokedexNumber: Int!
  name: MultiLangCreateOneInput!
  accuracy: Int!
  power: Int!
  pp: Int!
  type: PokemonTypeCreateOneInput!
}

type PokemonSkillEdge {
  node: PokemonSkill!
  cursor: String!
}

enum PokemonSkillOrderByInput {
  id_ASC
  id_DESC
  pokedexNumber_ASC
  pokedexNumber_DESC
  accuracy_ASC
  accuracy_DESC
  power_ASC
  power_DESC
  pp_ASC
  pp_DESC
}

type PokemonSkillPreviousValues {
  id: ID!
  pokedexNumber: Int!
  accuracy: Int!
  power: Int!
  pp: Int!
}

type PokemonSkillSubscriptionPayload {
  mutation: MutationType!
  node: PokemonSkill
  updatedFields: [String!]
  previousValues: PokemonSkillPreviousValues
}

input PokemonSkillSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PokemonSkillWhereInput
  AND: [PokemonSkillSubscriptionWhereInput!]
  OR: [PokemonSkillSubscriptionWhereInput!]
  NOT: [PokemonSkillSubscriptionWhereInput!]
}

input PokemonSkillUpdateInput {
  pokedexNumber: Int
  name: MultiLangUpdateOneRequiredInput
  accuracy: Int
  power: Int
  pp: Int
  type: PokemonTypeUpdateOneRequiredInput
}

input PokemonSkillUpdateManyMutationInput {
  pokedexNumber: Int
  accuracy: Int
  power: Int
  pp: Int
}

input PokemonSkillWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  pokedexNumber: Int
  pokedexNumber_not: Int
  pokedexNumber_in: [Int!]
  pokedexNumber_not_in: [Int!]
  pokedexNumber_lt: Int
  pokedexNumber_lte: Int
  pokedexNumber_gt: Int
  pokedexNumber_gte: Int
  name: MultiLangWhereInput
  accuracy: Int
  accuracy_not: Int
  accuracy_in: [Int!]
  accuracy_not_in: [Int!]
  accuracy_lt: Int
  accuracy_lte: Int
  accuracy_gt: Int
  accuracy_gte: Int
  power: Int
  power_not: Int
  power_in: [Int!]
  power_not_in: [Int!]
  power_lt: Int
  power_lte: Int
  power_gt: Int
  power_gte: Int
  pp: Int
  pp_not: Int
  pp_in: [Int!]
  pp_not_in: [Int!]
  pp_lt: Int
  pp_lte: Int
  pp_gt: Int
  pp_gte: Int
  type: PokemonTypeWhereInput
  AND: [PokemonSkillWhereInput!]
  OR: [PokemonSkillWhereInput!]
  NOT: [PokemonSkillWhereInput!]
}

input PokemonSkillWhereUniqueInput {
  id: ID
  pokedexNumber: Int
}

type PokemonSubscriptionPayload {
  mutation: MutationType!
  node: Pokemon
  updatedFields: [String!]
  previousValues: PokemonPreviousValues
}

input PokemonSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PokemonWhereInput
  AND: [PokemonSubscriptionWhereInput!]
  OR: [PokemonSubscriptionWhereInput!]
  NOT: [PokemonSubscriptionWhereInput!]
}

type PokemonType {
  id: ID!
  english: String!
  chinese: String!
  japanese: String!
}

type PokemonTypeConnection {
  pageInfo: PageInfo!
  edges: [PokemonTypeEdge]!
  aggregate: AggregatePokemonType!
}

input PokemonTypeCreateInput {
  english: String!
  chinese: String!
  japanese: String!
}

input PokemonTypeCreateManyInput {
  create: [PokemonTypeCreateInput!]
  connect: [PokemonTypeWhereUniqueInput!]
}

input PokemonTypeCreateOneInput {
  create: PokemonTypeCreateInput
  connect: PokemonTypeWhereUniqueInput
}

type PokemonTypeEdge {
  node: PokemonType!
  cursor: String!
}

enum PokemonTypeOrderByInput {
  id_ASC
  id_DESC
  english_ASC
  english_DESC
  chinese_ASC
  chinese_DESC
  japanese_ASC
  japanese_DESC
}

type PokemonTypePreviousValues {
  id: ID!
  english: String!
  chinese: String!
  japanese: String!
}

input PokemonTypeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  english: String
  english_not: String
  english_in: [String!]
  english_not_in: [String!]
  english_lt: String
  english_lte: String
  english_gt: String
  english_gte: String
  english_contains: String
  english_not_contains: String
  english_starts_with: String
  english_not_starts_with: String
  english_ends_with: String
  english_not_ends_with: String
  chinese: String
  chinese_not: String
  chinese_in: [String!]
  chinese_not_in: [String!]
  chinese_lt: String
  chinese_lte: String
  chinese_gt: String
  chinese_gte: String
  chinese_contains: String
  chinese_not_contains: String
  chinese_starts_with: String
  chinese_not_starts_with: String
  chinese_ends_with: String
  chinese_not_ends_with: String
  japanese: String
  japanese_not: String
  japanese_in: [String!]
  japanese_not_in: [String!]
  japanese_lt: String
  japanese_lte: String
  japanese_gt: String
  japanese_gte: String
  japanese_contains: String
  japanese_not_contains: String
  japanese_starts_with: String
  japanese_not_starts_with: String
  japanese_ends_with: String
  japanese_not_ends_with: String
  AND: [PokemonTypeScalarWhereInput!]
  OR: [PokemonTypeScalarWhereInput!]
  NOT: [PokemonTypeScalarWhereInput!]
}

type PokemonTypeSubscriptionPayload {
  mutation: MutationType!
  node: PokemonType
  updatedFields: [String!]
  previousValues: PokemonTypePreviousValues
}

input PokemonTypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PokemonTypeWhereInput
  AND: [PokemonTypeSubscriptionWhereInput!]
  OR: [PokemonTypeSubscriptionWhereInput!]
  NOT: [PokemonTypeSubscriptionWhereInput!]
}

input PokemonTypeUpdateDataInput {
  english: String
  chinese: String
  japanese: String
}

input PokemonTypeUpdateInput {
  english: String
  chinese: String
  japanese: String
}

input PokemonTypeUpdateManyDataInput {
  english: String
  chinese: String
  japanese: String
}

input PokemonTypeUpdateManyInput {
  create: [PokemonTypeCreateInput!]
  update: [PokemonTypeUpdateWithWhereUniqueNestedInput!]
  upsert: [PokemonTypeUpsertWithWhereUniqueNestedInput!]
  delete: [PokemonTypeWhereUniqueInput!]
  connect: [PokemonTypeWhereUniqueInput!]
  set: [PokemonTypeWhereUniqueInput!]
  disconnect: [PokemonTypeWhereUniqueInput!]
  deleteMany: [PokemonTypeScalarWhereInput!]
  updateMany: [PokemonTypeUpdateManyWithWhereNestedInput!]
}

input PokemonTypeUpdateManyMutationInput {
  english: String
  chinese: String
  japanese: String
}

input PokemonTypeUpdateManyWithWhereNestedInput {
  where: PokemonTypeScalarWhereInput!
  data: PokemonTypeUpdateManyDataInput!
}

input PokemonTypeUpdateOneRequiredInput {
  create: PokemonTypeCreateInput
  update: PokemonTypeUpdateDataInput
  upsert: PokemonTypeUpsertNestedInput
  connect: PokemonTypeWhereUniqueInput
}

input PokemonTypeUpdateWithWhereUniqueNestedInput {
  where: PokemonTypeWhereUniqueInput!
  data: PokemonTypeUpdateDataInput!
}

input PokemonTypeUpsertNestedInput {
  update: PokemonTypeUpdateDataInput!
  create: PokemonTypeCreateInput!
}

input PokemonTypeUpsertWithWhereUniqueNestedInput {
  where: PokemonTypeWhereUniqueInput!
  update: PokemonTypeUpdateDataInput!
  create: PokemonTypeCreateInput!
}

input PokemonTypeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  english: String
  english_not: String
  english_in: [String!]
  english_not_in: [String!]
  english_lt: String
  english_lte: String
  english_gt: String
  english_gte: String
  english_contains: String
  english_not_contains: String
  english_starts_with: String
  english_not_starts_with: String
  english_ends_with: String
  english_not_ends_with: String
  chinese: String
  chinese_not: String
  chinese_in: [String!]
  chinese_not_in: [String!]
  chinese_lt: String
  chinese_lte: String
  chinese_gt: String
  chinese_gte: String
  chinese_contains: String
  chinese_not_contains: String
  chinese_starts_with: String
  chinese_not_starts_with: String
  chinese_ends_with: String
  chinese_not_ends_with: String
  japanese: String
  japanese_not: String
  japanese_in: [String!]
  japanese_not_in: [String!]
  japanese_lt: String
  japanese_lte: String
  japanese_gt: String
  japanese_gte: String
  japanese_contains: String
  japanese_not_contains: String
  japanese_starts_with: String
  japanese_not_starts_with: String
  japanese_ends_with: String
  japanese_not_ends_with: String
  AND: [PokemonTypeWhereInput!]
  OR: [PokemonTypeWhereInput!]
  NOT: [PokemonTypeWhereInput!]
}

input PokemonTypeWhereUniqueInput {
  id: ID
  english: String
}

input PokemonUpdateInput {
  pokedexNumber: Int
  nameSearch: String
  name: MultiLangUpdateOneRequiredInput
  types: PokemonTypeUpdateManyInput
  base: PokemonBaseStatsUpdateOneRequiredInput
}

input PokemonUpdateManyMutationInput {
  pokedexNumber: Int
  nameSearch: String
}

input PokemonWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  pokedexNumber: Int
  pokedexNumber_not: Int
  pokedexNumber_in: [Int!]
  pokedexNumber_not_in: [Int!]
  pokedexNumber_lt: Int
  pokedexNumber_lte: Int
  pokedexNumber_gt: Int
  pokedexNumber_gte: Int
  nameSearch: String
  nameSearch_not: String
  nameSearch_in: [String!]
  nameSearch_not_in: [String!]
  nameSearch_lt: String
  nameSearch_lte: String
  nameSearch_gt: String
  nameSearch_gte: String
  nameSearch_contains: String
  nameSearch_not_contains: String
  nameSearch_starts_with: String
  nameSearch_not_starts_with: String
  nameSearch_ends_with: String
  nameSearch_not_ends_with: String
  name: MultiLangWhereInput
  types_every: PokemonTypeWhereInput
  types_some: PokemonTypeWhereInput
  types_none: PokemonTypeWhereInput
  base: PokemonBaseStatsWhereInput
  AND: [PokemonWhereInput!]
  OR: [PokemonWhereInput!]
  NOT: [PokemonWhereInput!]
}

input PokemonWhereUniqueInput {
  id: ID
  pokedexNumber: Int
}

type Query {
  item(where: ItemWhereUniqueInput!): Item
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item]!
  itemsConnection(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ItemConnection!
  multiLangs(where: MultiLangWhereInput, orderBy: MultiLangOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MultiLang]!
  multiLangsConnection(where: MultiLangWhereInput, orderBy: MultiLangOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MultiLangConnection!
  pokemon(where: PokemonWhereUniqueInput!): Pokemon
  pokemons(where: PokemonWhereInput, orderBy: PokemonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Pokemon]!
  pokemonsConnection(where: PokemonWhereInput, orderBy: PokemonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PokemonConnection!
  pokemonBaseStatses(where: PokemonBaseStatsWhereInput, orderBy: PokemonBaseStatsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PokemonBaseStats]!
  pokemonBaseStatsesConnection(where: PokemonBaseStatsWhereInput, orderBy: PokemonBaseStatsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PokemonBaseStatsConnection!
  pokemonSkill(where: PokemonSkillWhereUniqueInput!): PokemonSkill
  pokemonSkills(where: PokemonSkillWhereInput, orderBy: PokemonSkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PokemonSkill]!
  pokemonSkillsConnection(where: PokemonSkillWhereInput, orderBy: PokemonSkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PokemonSkillConnection!
  pokemonType(where: PokemonTypeWhereUniqueInput!): PokemonType
  pokemonTypes(where: PokemonTypeWhereInput, orderBy: PokemonTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PokemonType]!
  pokemonTypesConnection(where: PokemonTypeWhereInput, orderBy: PokemonTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PokemonTypeConnection!
  node(id: ID!): Node
}

type Subscription {
  item(where: ItemSubscriptionWhereInput): ItemSubscriptionPayload
  multiLang(where: MultiLangSubscriptionWhereInput): MultiLangSubscriptionPayload
  pokemon(where: PokemonSubscriptionWhereInput): PokemonSubscriptionPayload
  pokemonBaseStats(where: PokemonBaseStatsSubscriptionWhereInput): PokemonBaseStatsSubscriptionPayload
  pokemonSkill(where: PokemonSkillSubscriptionWhereInput): PokemonSkillSubscriptionPayload
  pokemonType(where: PokemonTypeSubscriptionWhereInput): PokemonTypeSubscriptionPayload
}
`